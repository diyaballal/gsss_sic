Day 2:
OPERATORS:
+ - * / ^ %
Power operator: right to left i.e: 2**3**2: 3**2 first
others: left to right
all operators are binary operators


BITS & BYTES:
Binary:01 --> 0*2^1 + 1*2^2
Octal:0-7 --> 0o77: 7*8^1 +  7*8^0
Hexadecimal:10-15:a-f
+ve,-ve,floating no.s are stored in different ways
When there are 2 no.s float and integer, it converts integer no. into float not the other way around: 5+6.055  -> 5.0+6.055
4 - 5 % 7
4 + 8 + 9
Expressions are read from L->R but:
These are evaluated only after converting user given infix notation expression into postfix expression.


RELATIONAL OPERATORS:
< > <= >= != ==
Higher precedance than logical op but lesser than arithematic.
for loops <= and >= are better options.


LOGICAL OPERATORS:
& && | || !(c,c++,java etc)
and or not (python)
i/p: boolean
o/p:boolean
Higher precedance than assignment op.

*********************************************************************

DAY 3:
Single threaded and multi threaded applications

LISTS:
We use argv using sys i.e sys.argv
print(sys.argv) --> prints argv list
print(type(sys.argv)) -->prints the type of argv
print(sys.argv[0]) -->prints the 1st element
print(sys.argv[1]) -->prints the 2nd element 

RANGE:
range(10) : start from 0 upto 9 (increment of +1 by default)
range(2,10): start from 2 (user given start) upto 9( one before 10)
range(2,10,3): start from 2 (user given start) upto 9( one before 10) and increment of 3
range(90,10,-4): start from 90 (user given start) upto 9( one before 10) and increment of -4(or decrement od +4)

Note:
dave.mozilla :html,css
docs.python.org :python
docs.oracle.com :java
IBM,micro,cisco: C,C++

functions called via an object --> method 
functions called alone --> functions
Map: access all elements one by one 
numbers=list(map(int,sys.argv[1:])) --> other than d 2nd element the rest of the list is being taken as int. 
										and next it is mapped i.e every element accessed once. 
										Finally converted into list form.

import pymysql:
run mysql queries through python

EXCEPTION:
Instruction is trying to run but cannot.
In memory an object of that particular exception class is created. And the ref value address is thrown, if nobody catches this:
pvm:python virtual machine: stops execution and simply displays the stack trace.

Two type of except statements:
Specialised except blocks: except ValueError, except TypeError
Generic except block: except: ... --> except any type of errors 
All specialised errors are child of generic errrors. Therefore inheritance concept. parent:except; child: except TypeError.


Keywords in exception handling:
tryingexcept
throws
raise 
classes:exception,valueerror,typeerror

*********************************************************************
DAY4:

FUNCTIONS:
A non dafult arguement cannot be followed after a default arguement.
Constant value is also called as a literal.

In how many different ways the below function can called?

def my_function(num1 = 100, num2 = 400):
    return num1 - num2

print(my_function(None, 20))
print(my_function(None, None))
print(my_function(20, None))
my_function(10, 20)
my_function(10)
my_function()
my_function(num1 = 25)
my_function(None, 20)
my_function(num2 = 25)
my_function(num2 = 25, num1 = 99)
my_function(num1 = 25, num2 = 99)


LIST:
What: A colletion of items(data)
Stored: All items are stored in contigious memory locations. i.e if you take any 2 consecutive elements, then there will not be any gap between them.
Type: Need not be of the same type in python.

What is Data Structure?
Arrangement of data in a specific way without any ambiguity.

In Unary : * : Valueat or Dereferencing operator
n[0] --> *(n+0) where n is the address  and 0 is the element . Therefore:
adress + element = address.
adress - element = address.
address - address= number. --> index valuees of all the elements thats between those two addresses.
						   --> These addresses have to be of the same array.
These are the only 3 arithematic address operators.	

The lookup of an array: accessing any element in the list/array is 1 unit time.
Therefore efficiency of accessing an element in array is O(1)

*In other languages:* size of array is fixed which leads to wastage/shortage of memory. Therfore an array is time efficient but not in space.
Memory is allocated in run time for all but how much memory allocated is decided in the run time is called dynamic memory allocation.

C++:														Java:															Python:		
Allocation: float *numbers=new float[size]; 				Allocation: float[] numbers= new float[size]					Allocation: Automatic
Deallocation: delete()										Deallocation: Automatic(garbagecollector)						Deallocation:Automatic

Alternate of array: Linked list
There will never be a wastage of memory in Linked list because the memory allocated will be very specific to the elements.

Accessers (get): Function that acceses values of variables. 
Setters (set): Sets the values 


OOPS:
CREATE OBJECTS:
Account* account = new Account(); --> C++
Account account = new Account(); --> Java
account = Account() --> Python

Encapsulation and Abstraction go hand-in-hand.

Class: Solution for an entity.

Inheritance:
Child class has all the properties of parent class + its own properties.

Polymorphism:
One problem, multiple solutions.

Deep copy: Creating a duplicte copy of the existing list
Shallow copy: Copying only the address of the existing list

Types of list  methods:
1. Create + initialising:
	list()
2. append()
	Adding an element to the end of the list
3. pop()
	Deleting the element from the last and returning that element.
4.insert()
	Inserting at a specific index
5.remove()
	Delete a specific element from the list.If exists more than once, it will remove the first occuring one.
6.sort()
	list1.sort()==> Sorts in ascending order
7.reverse()
	list1.sort(reverse=True)==> sorts in decending order
8.extend()
	Basically the elements get added into another list. Ex: list1=[1,2] list2=[3,4], list1.extend(list2)==> [1,2,3,4] whereas: list1.append(list2)==> [1,2[3,4]]
9.sorted()
	list2=sorted(list1) ==> When you want another copy of list1 but in ascended order. This is also a deepcopy of list1 named as list2.
10. clear()
	Deletes all elements in the list but the list will still exist.
11. eq()
	checks whether 2 lists are equal
12. sizeof()
	To check the size of list
13. str()
	To convert the list as a string. value=list1.__str__()
14. len()
	Length of the number of elements. value=list1.__len__()
15.count()
	list1.count(13) ==> shows the no. of times 13 has been repeated in the list.
16. index()
	list1.index(5) ==> Shows the value of that particular index element 


*******************************************************************************************************


DAY 5:
LIST SLICING:
No IndexError in slicing. [Start or End value]
It will simply ignore the stop value if it doesnt exist.
Ex: capitals [1:17] will still work even if there arent that many elements.

[3:2]  --> empty list 
[3:3]  --> empty list
[-1]   -->last element

When given +ve index: Starts from index value:0
When given -ve index: Starts from index value:1

Conversion: i] List --> string
		   ii] String --> List

i] Give a list say list1
   variable_name=''.join(list1)

ii] list2=[element for element in variable_name]

STRING CLASS METHODS:
find
index
capitalize
upper
lower
trim




*******************************************************************


DAY 6:

EXCEPTIONS IN PYTHON
Exception Handling

What is an Exception?
What happens when an exception is created?
What can be done when an exception is created?
How an error is named?

Usually in Python we use snake_case
In Java we use camelCase
PascalCase is what we use to name Errors in Python/Java

What is an Exception?
When we are asking via an instruction to the PVM (execution machine) to run but it cannot be run, then an exception is created.

For example, if we ask a number, say 450 to be divided by zero:
450/0
which cannot be done, then an exception occurs.
2nd example, we are trying to connect to a DB, but the DB doesn't exist, then an exception occurs.

What are different exceptions:

TypeError

ValueError

NameError

ZeroDivisionError

IndexError
when we are trying to access 10th element in a list, but it has just 6 elements.

----------------------------------------------------------------
What happens when an exception is created?

When an exception is created, an object of a specific class is created and its reference value is thrown.

What can be done when an exception is created?
Handle the exception!

The mechanism to handle an exception:
which is the try-except blocks!

It is the try block where we put in the code which we SUSPECT where the exception may occur.
How do we suspect?
With our previous development experience.
We should also know what exception(s) may be created.
Such suspected code we put it into try block.
Now, if by chance as we suspected, if the exception occurs, it is the except block which CATCH the reference value of the object of the specific Error(exception) class.

RULES FOR EXCEPTION HANDLING:
-> The try and except blocks must be a pair similar to if-else. i.e., the except block must immediately follow the try block. In between these 2 blocks, we cannot define any other instructions.
-> Each try block can have more than one except blocks. But only one of the except block is executed.
-> If there are multiple except blocks defined, then they are executed similar to the cases inside a match block. That is, the reference value which is thrown is compared with the except blocks in the order of their definition.
-> We can nest a try block with in other.

what do we do within a except block?
We try to give a solution for the error that has occured.
Once an exception has occured, the remaining statements inside the try block are skipped. Thus the normal flow of execution is disturbed.
So we have to take round  (change the path of execution) and reach a specific except block (if matches) execute it and then the remaining statements after the except block are executed.

-> The try and ecxept blocks are defined within a function/method.
-> If none of the except blocks match, then again the exception/error is controlled by PVM which stops the execution and prints the stack trace of the error.
-> So to avoid none of the except blocks are matched we can define a generic except block which can accept any type of error.
-> If none of the except blocks of the inner try matches, then the PVM will continue to match the error with thye except blocks of the outer try block.
-> If we have defined and placed the generic except block above the specialized except blocks then the specialized ones will be unreachable and this will turn into syntax error.

Further Learning:
propogating the exceptions to the caller (throws keyword)
Raising/creating an exception explicitly.

Keywords we use in exception handling:
try
except
throw/raise
throws (The method where the exception has occured may defy handling the exception and propogate it to its caller)

-> By introduing the exception handling, we can continue the execution of the App/Program.
-> What happens if no exception occurs?
All the instructions in the try block will complete and all the except blocks are skipped and the statements defined after the except blocks are run and thus the function/method completes the execution normally.

--------------------------------------------------------------------------------------------


SPECIAL PURPOSE REGISTERS
Accumulators: It is used to store intermediate results.
MAR: Memory address registers 
MDR: Memory data registers 
IR: Instruction register -> It holds address of the instruction that is currently running (getting executed)
PC: Program Counter -> It holds address of the next instruction to be executed
SP: Stack Pointer -> It holds address of the top frame in the stack.
FP: Frame Pointer -> It holds address of the frame of function which is currently running.


-----------------------------------------------------------------

Frame: A frame is memory allocated to a function during runtime.

Contents of a Frame:
    the local variables
    the function arguments
    linkages (address of the functions we are calling)
    return address


.class: java
.obj: c/c++

BLOCK DIAGRAM:
Code area: compiled code of java(byte code:can be accessed anywhere) or C(object code: OS specific ). 
G.D.S: Global variables are stored
Stack area:All frames of the functions are stored here. The address of the objects created also stored.
Heap Area: Dynamically allocated memory is stored here. Objects created are stored here.

Callee: the function being called.
Calling: The function thats calling a function.

When the FP and SP both are NULL only then the application is said to be completed.
After the top element in SP is completed it is automatically popped and deleted.

RECURSION:
A function that calls itself. When the caller and callee are one at the same function.
Such a function is called recursive function and such a call statement is called as recursive call.

Avoid recursion when we can easily solve the problem iteratively.