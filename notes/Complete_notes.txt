Day 2:
OPERATORS:
+ - * / ^ %
Power operator: right to left i.e: 2**3**2: 3**2 first
others: left to right
all operators are binary operators


BITS & BYTES:
Binary:01 --> 0*2^1 + 1*2^2
Octal:0-7 --> 0o77: 7*8^1 +  7*8^0
Hexadecimal:10-15:a-f
+ve,-ve,floating no.s are stored in different ways
When there are 2 no.s float and integer, it converts integer no. into float not the other way around: 5+6.055  -> 5.0+6.055
4 - 5 % 7
4 + 8 + 9
Expressions are read from L->R but:
These are evaluated only after converting user given infix notation expression into postfix expression.


RELATIONAL OPERATORS:
< > <= >= != ==
Higher precedance than logical op but lesser than arithematic.
for loops <= and >= are better options.


LOGICAL OPERATORS:
& && | || !(c,c++,java etc)
and or not (python)
i/p: boolean
o/p:boolean
Higher precedance than assignment op.

*********************************************************************

DAY 3:
Single threaded and multi threaded applications

LISTS:
We use argv using sys i.e sys.argv
print(sys.argv) --> prints argv list
print(type(sys.argv)) -->prints the type of argv
print(sys.argv[0]) -->prints the 1st element
print(sys.argv[1]) -->prints the 2nd element 

RANGE:
range(10) : start from 0 upto 9 (increment of +1 by default)
range(2,10): start from 2 (user given start) upto 9( one before 10)
range(2,10,3): start from 2 (user given start) upto 9( one before 10) and increment of 3
range(90,10,-4): start from 90 (user given start) upto 9( one before 10) and increment of -4(or decrement od +4)

Note:
dave.mozilla :html,css
docs.python.org :python
docs.oracle.com :java
IBM,micro,cisco: C,C++

functions called via an object --> method 
functions called alone --> functions
Map: access all elements one by one 
numbers=list(map(int,sys.argv[1:])) --> other than d 2nd element the rest of the list is being taken as int. 
										and next it is mapped i.e every element accessed once. 
										Finally converted into list form.

import pymysql:
run mysql queries through python

EXCEPTION:
Instruction is trying to run but cannot.
In memory an object of that particular exception class is created. And the ref value address is thrown, if nobody catches this:
pvm:python virtual machine: stops execution and simply displays the stack trace.

Two type of except statements:
Specialised except blocks: except ValueError, except TypeError
Generic except block: except: ... --> except any type of errors 
All specialised errors are child of generic errrors. Therefore inheritance concept. parent:except; child: except TypeError.


Keywords in exception handling:
tryingexcept
throws
raise 
classes:exception,valueerror,typeerror

*********************************************************************

